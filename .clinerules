# Project Guidelines

This document outlines the project-specific rules and guidelines for development.

## Documentation Requirements

- Update relevant documentation in a `docs` directory when modifying features.
- Keep `README.md` in sync with new capabilities and setup instructions.
- Maintain changelog entries in a `CHANGELOG.md` file.

## Code Style & Patterns

- Adhere to TypeScript best practices and utilize type checking.
- Follow the code formatting defined in `.prettierrc.js`.
- Utilize Tailwind CSS for styling, following the configuration in `tailwind.config.ts`.
- Prefer functional components and React hooks in `web/src`.
- Define API endpoints using tRPC in `web/src/server/api/routers`.
- Ensure clear separation of concerns between client and server code.

## Database Schema and Migrations

- All database schema changes must be made in `prisma/schema.prisma`.
- Generate and apply new migrations using Prisma Migrate for any schema changes.

## Testing Standards

- Write unit tests for business logic and utility functions.
- Implement integration tests for API endpoints and data access layers.
- Consider end-to-end tests for critical user flows.

## Project Structure

- Organize web application code within the `web` directory.
- Place data scraping scripts in the `scraper` directory.
- Manage database schema and migrations within the `prisma` directory.

## UI Component Usage

- When building pages, utilize the components provided in `web/src/components/ui/`.
- Import components directly from the UI library path.
- Ensure components are used according to their intended purpose and props.
- Example:

  ```typescript
  import { Button } from "@/components/ui/button";
  import { Input } from "@/components/ui/input";

  function MyPage() {
    return (
      <div>
        <Input placeholder="Enter your name" />
        <Button>Submit</Button>
      </div>
    );
  }
  ```

## tRPC Best Practices

- Define tRPC routers in `web/src/server/api/routers/`.
- Keep router logic focused on specific domains (e.g., `userRouter.ts`, `postRouter.ts`).
- Utilize input and output validation using Zod.
- Handle errors gracefully and return appropriate tRPC errors.
- Use the `api` object generated by `web/src/trpc/react.tsx` for type-safe API calls in the client.
- Example:

  ```typescript
  // web/src/server/api/routers/example.ts
  import { z } from "zod";
  import { createTRPCRouter, publicProcedure } from "@/server/api/trpc";

  export const exampleRouter = createTRPCRouter({
    hello: publicProcedure
      .input(z.object({ text: z.string() }))
      .query(({ input }) => {
        return {
          greeting: `Hello ${input.text}`,
        };
      }),
  });

  // web/src/app/page.tsx
  import { api } from "@/trpc/react";

  function HomePage() {
    const { data } = api.example.hello.useQuery({ text: "world" });

    return (
      <div>
        <p>{data ? data.greeting : "Loading..."}</p>
      </div>
    );
  }
  ```

## Form Handling with react-hook-form and tRPC

- Use `react-hook-form` for managing form state and validation.
- Integrate with Zod for schema-based validation.
- Connect form inputs using `shadcn/ui` form components.
- Handle form submission by calling tRPC mutations within the `handleSubmit` function.
- Example:

  ```typescript
  "use client";

  import { Button } from "@/components/ui/button";
  import {
    Form,
    FormControl,
    FormField,
    FormItem,
    FormLabel,
    FormMessage,
  } from "@/components/ui/form";
  import { Input } from "@/components/ui/input";
  import { api } from "@/trpc/react";
  import { zodResolver } from "@hookform/resolvers/zod";
  import { useForm } from "react-hook-form";
  import { z } from "zod";

  // 1. Define your form schema using Zod
  const formSchema = z.object({
    name: z.string().min(2, {
      message: "Name must be at least 2 characters.",
    }),
    email: z.string().email({
      message: "Please enter a valid email address.",
    }),
  });

  export default function ContactForm() {
    // 2. Initialize useForm with your schema and resolver
    const form = useForm<z.infer<typeof formSchema>>({
      resolver: zodResolver(formSchema),
      defaultValues: {
        name: "",
        email: "",
      },
    });

    // 3. Define your tRPC mutation
    const contactMutation = api.contact.create.useMutation({
      onSuccess: () => {
        // Handle success (e.g., show a success message, reset the form)
        form.reset();
        alert("Message sent successfully!");
      },
      onError: (error) => {
        // Handle errors
        alert(`Error: ${error.message}`);
      },
    });

    // 4. Define your submit handler
    function onSubmit(values: z.infer<typeof formSchema>) {
      // 5. Call the tRPC mutation with form data
      contactMutation.mutate(values);
    }

    return (
      // 6. Wrap your form with the Form component and connect inputs with FormField
      <Form {...form}>
        <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8">
          <FormField
            control={form.control}
            name="name"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Name</FormLabel>
                <FormControl>
                  <Input placeholder="Your name" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
          <FormField
            control={form.control}
            name="email"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Email</FormLabel>
                <FormControl>
                  <Input placeholder="Your email" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
          <Button type="submit" disabled={contactMutation.isPending}>
            {contactMutation.isPending ? "Submitting..." : "Submit"}
          </Button>
        </form>
      </Form>
    );
  }
  ```
